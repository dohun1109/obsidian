멀티 스레드 : 하나의 프로세스 안에서 두가지 이상의 작업을 처리하는 것. 

- 멀티 프로세스는 하나의 프로세스에서 오류가 발생해도 다른 프로세스에 영향을 미치지 않는다 . 하지만 멀티 스레드는 프로세스 내부에서 생성되기 때문에 하나의 스레드가 예외를 발생시키면 프로세스가 종료되므로  다른 스레드에게 영향을 미친다. 
  
- 예를 들어 워드와 엑셀을 동시에 사용하는 도중에 워드에 오류가 생겨 먹통이 되더라도 엑셀은 여전히 사용 가능하다. 그러나 멀티 스레드로 동작하는 메신저의 경우, 파일을 전송하는 스레드에서 예외가 발생하면 메신저 프로세스 자체가 종료되기 때문에 채팅 스레드도 같이 종료된다. 그렇기 때문에 멀티 스레드를 사용할 경우에는 예외처리에 만전을 기해야 한다. 
- 멀티 스레드는 데이터를 분할해서 병렬로 처리하는 곳에서 사용하기도 하고, 안드로이드 앱에서 네트워크 통신을 하기 위해 사용하기도 한다. 또한 다수의 클라이언트 요청을 처리하는 서버를 개발할 때도 사용된다. 



---
## 스레드 상태 
- 스레드 객체를 생성(new) 하고, start() 메소드를 호출하면 곧바로 스레드가 실행되는 것이 아니라 실행 대기 상태 (Runable)가 된다. 
- 실행 대기하는 스레드는 CPU 스케쥴링 따라 CPU를 점유하고 run() 메소드를 실행한다. 이때를 실행 상태라고 한다 . 실행 스레드는 run() 메소드를 모두 실행하기 전에 스케쥴링에 의해 다시 실행 대기 상태로 돌아 갈 수 있다. 그리고 다른 스레드가 실행 상태가 된다. 
- 이렇게 스레드는 실행 대기 상태와 실행 상태를 번갈아 가면서 자신의 run()메소드를 조금씩 실행한다. 실행 상태에서 run() 메소드가 종료 되면 더 이상 실행할 코드가 없기 때문에 스레드의 실행은 멈추게 된다. 이 상태를 종료상태(Terminated) 라고 한다. 


> 실행 상태에서 일시 정지 상태로 가기도 하는데, 일시 정지 상태는 스레드가 실행할 수 없는 상태를 말한다. 
> 스레드가  다시 실행 상태로 가기 위해서는 일시 정지 상태에서 실행 대기 상태로 가야만 한다. 

> [!NOTE] 일시 정지로 보냄 
> - sleep() -> 주어진 시간 동안 스레드를 일시 정지 상태로 만든다. 주어진 시간이 지나면 자동적으로 실행 대기 상태가 된다. 
> - join() -> join() method를 호출한 스레드는 일시 정지 상태가 된다. 실행 대기 상태가 되려면 , join() method가 종료되어야 하낟. 
> - wait() -> 동기화 블록 내에서 스레드를 일시 정지 상태로 만든다. 

>[!WARNING] 일시 정지에서 벗어남 
> -  interrupt() -> 일시 정지 상태일 경우, interruptedException을 발생시켜 실행 대기 상태 or 종료 상태로 만든다. 
> - notify()  , notifyAll() -> wait() method 인해 일시 정지 상태인 스레드를 실행 대기 상태로 만든다 . 


>[!TIP] 실행 대기로 보냄 
>- yield() -> 실행 상태에서 다른 스레드에게 실행을 양보하고 실행 대기 상태가 된다. 


---

## 다른 스레드에게 실행 양보 
스레드가 처리하는 작업은 박복적인 실행을 위해 for 문이나 while 문을 포함하는 경우가 많은데 , 가끔 반복문이 무의미한 반복을 하는 경우가 많다. 다음 코드에서 work의 값이 false 라면 while 문은 어떤한 실행문도 실행하지 않고 무의미한 반복을 한다. 

```java 
	public void run(){
		while(true){
			System.out.println("ThreadA 작업 내용");
		}
	}
```


이때는 다른 스레드에게 실행을 양보하고 자신은 실행 대기 상태로 가는 것이 프로그램 성능에 동움이 된다. 
이런 기능을 위해 Thread 는 yeild() method를 제공한다. 


---
## 스레드 동기화 
멀티스레드는 하나의 객체를 공유해서 작업할 수도 있다. 이경우 다른 스레드에 의해 객체 내부 데이터가 쉽게 변경될 수 있기 때문에 의도 했던 것과는 다른 결과가 나올수 있다. 

스레드 동기화 메소드는 실행하는 즉시 객체가 잠금이 일어나고 메소드 실행이 끝나면 잠금이 풀린다. 
```java 
	public synchronized void method(){
		//단 하나의 스레드만 실행하는 영역 
	}
```

메소드 전체가 아닌 일부 영역을 실행 할 때 만 객체 잠금이 일어나고 일부영역이 지나면 다시 풀리도록 하고 싶다면 동기화 블럭을 사용할 수 있다. 

```java 
	public void method(){
		// 여러 스레드가 객체 공유를 할 수 있는 영역

		sychronized(공유 객체){
			//객체 잠금 
		}

	}
```



---

## wait() 과 notify() 를 이용한 스레드 제어 

경우에 따라서 두 개의 스레드를 번갈아 가며 실행 할 때도 있다. 그리고 정확한 교대 작업이 
필요할 경우 자신의 작업이 끝나면 상대방 스레드를 일 시정지 상태에서 풀어주고 자신은 일시 정지 상태로 만들면 된다.



---


## 데몬 스레드 (Daemon Thread)
 데몬 스레드는 주 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드이다. 주 스레드가 종료되면 데몬 스레드도 따라서 자동으로 종료된다. 
 데몬 스레드를 적용한 예로는 워드프로세서의 자동 저장, 미디어플레이어의 동영상 및 음악 재생, 가비지 컬렉터 등이 있는데, 여기에서 주 스레드( 워드프로세스, 미디어 플레이어, JVM) 가 종료되면 데몬 스레드도 같이 종료된다. 
 스레드를 데몬으로 만들기 위해서는 주 스레드가 데몬이 될 스레드의 setDaemon(true)를 호출하면 된다. 다음 예를 보면 메인스레드는 주 스레드, AutoSaveThread는 데몬 스레드가 된다.

```java
	public static void main(String[] args){
		AutoSaveThread thread = new AutoSaveThread();
		thread.setDaemon(true);
		thread.start();
		...
	}
```


---


## 스레드 풀 
- 병렬 작업 처리가 많아지면 스레드의 개수가 폭증하여 CPU가 바빠지고 메모리 사용량이 늘어난다. 이에따라 애플리케이션의 서능 또한 급격히 저하된다. 

이렇게 병렬작업 증가인한 스레드의 폭증을 막으려면 스레드 풀을 사용하는 것이 좋다.


스레드 풀은 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고 작업 큐에 들어오는 작업들을 스레드가 하나씩 맡아 처리하는 방식이다. 작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리한다. 이렇게 하면 작업량이 증가해도 스레드의 개수가 늘어나지 않아 애플리케이션의 성능이 저하되지 않는다. 


>[!NOTE] 스레드풀 종료 
> 스레드풀의 스레드는 기본적으로 데몬 스레드가 아니기 때문에 main 스레드가 종료되더라도 작업을 처리하기 위해 계속 실행 상태로 남아 있다. 

>[!WARNING] 작업 생성과 처리요청 
> 하나의 작업은 Runnable 또는 Callable 구현 객체로 표현한다. Runnable 과 Callable 의 차이점은 작업 처리 완료후 리턴 값이 있는냐 없느냐 차이이다. 


